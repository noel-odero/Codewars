<h2><a href=https://www.codewars.com/kata/5916c87540ef95d8e1000007/train/typescript target="_blank">Learning TypeScript. Advanced Types. Intersection Types</a></h2><h3>6 kyu</h3><h1 id="learning-typescript-advanced-types-intersection-types">Learning TypeScript. Advanced Types. Intersection Types</h1><p>An intersection type combines multiple types into one. This allows you to add together existing types to get a single type that has all the features you need. For example, Person &amp; Serializable &amp; Loggable is a Person and Serializable and Loggable. That means an object of this type will have all members of all three types.</p><p>You will mostly see intersection types used for mixins and other concepts that don’t fit in the classic object-oriented mold. (There are a lot of these in JavaScript!) Here’s a simple example that shows how to create a mixin:</p><pre><code class="language-typescript"><span class="cm-keyword">function</span> <span class="cm-def">extend</span><span class="cm-operator">&lt;</span><span class="cm-type">T</span> <span class="cm-keyword">extends</span> <span class="cm-type">Object</span>, <span class="cm-type">U</span> <span class="cm-keyword">extends</span> <span class="cm-type">Object</span><span class="cm-operator">&gt;</span>(<span class="cm-def">first</span>: <span class="cm-type">T</span>, <span class="cm-def">second</span>: <span class="cm-type">U</span>): <span class="cm-type">T</span> <span class="cm-operator">&amp;</span> <span class="cm-type">U</span> {    <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-operator">&lt;</span><span class="cm-variable">T</span> <span class="cm-operator">&amp;</span> <span class="cm-variable">U</span><span class="cm-operator">&gt;</span>{};    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">id</span> <span class="cm-keyword">in</span> <span class="cm-variable-2">first</span>) {        (<span class="cm-operator">&lt;</span><span class="cm-variable">any</span><span class="cm-operator">&gt;</span><span class="cm-variable-2">result</span>)[<span class="cm-variable-2">id</span>] <span class="cm-operator">=</span> (<span class="cm-operator">&lt;</span><span class="cm-variable">any</span><span class="cm-operator">&gt;</span><span class="cm-variable-2">first</span>)[<span class="cm-variable-2">id</span>];    }    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">id</span> <span class="cm-keyword">in</span> <span class="cm-variable-2">second</span>) {        <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">result</span>.<span class="cm-property">hasOwnProperty</span>(<span class="cm-variable-2">id</span>)) {            (<span class="cm-operator">&lt;</span><span class="cm-variable">any</span><span class="cm-operator">&gt;</span><span class="cm-variable-2">result</span>)[<span class="cm-variable-2">id</span>] <span class="cm-operator">=</span> (<span class="cm-operator">&lt;</span><span class="cm-variable">any</span><span class="cm-operator">&gt;</span><span class="cm-variable-2">second</span>)[<span class="cm-variable-2">id</span>];        }    }    <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;}<span class="cm-keyword">class</span> <span class="cm-def">Person</span> {    <span class="cm-property">constructor</span>(<span class="cm-keyword">public</span> <span class="cm-def">name</span>: <span class="cm-type">string</span>) { }}<span class="cm-keyword">interface</span> <span class="cm-def">Loggable</span> {    <span class="cm-property">log</span>(): <span class="cm-type">void</span>;}<span class="cm-keyword">class</span> <span class="cm-def">ConsoleLogger</span> <span class="cm-keyword">implements</span> <span class="cm-type">Loggable</span> {    <span class="cm-property">log</span>() {        <span class="cm-comment">// ...</span>    }}<span class="cm-keyword">var</span> <span class="cm-def">jim</span> <span class="cm-operator">=</span> <span class="cm-variable">extend</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Person</span>(<span class="cm-string">"Jim"</span>), <span class="cm-keyword">new</span> <span class="cm-variable">ConsoleLogger</span>());<span class="cm-keyword">var</span> <span class="cm-def">n</span> <span class="cm-operator">=</span> <span class="cm-variable">jim</span>.<span class="cm-property">name</span>;<span class="cm-variable">jim</span>.<span class="cm-property">log</span>();</code></pre><h2 id="task">Task</h2><p>In the example above you can see that <code>extends</code> function returns <code>T &amp; U</code> which should correspond to intersection of types <code>T</code> and <code>U</code>. But in fact it returns object containing all properties from <code>T</code> mixed with additional properties from <code>U</code>.</p><p>Your task is to create function <code>intersect</code> which returns object with properties that are present simultaneously in <code>T</code> and <code>U</code>.</p><p><strong>P.S.</strong> Solved this kata? Take a look at other katas in "<a href="https://www.codewars.com/collections/learning-typescript" data-turbolinks="false" target="_blank">Learning TypeScript</a>" collection.</p>