<h2><a href=https://www.codewars.com/kata/59182a2f40ef95046400003c/train/typescript target="_blank">Learning TypeScript. Advanced Types. Union Types</a></h2><h3>7 kyu</h3><h1 id="learning-typescript-advanced-types-union-types">Learning TypeScript. Advanced Types. Union Types</h1><h3 id="overview">Overview</h3><p>Union types are closely related to <a href="https://www.codewars.com/kata/learning-typescript-advanced-types-intersection-types" data-turbolinks="false" target="_blank">intersection types</a>, but they are used very differently. Occasionally, you’ll run into a library that expects a parameter to be either a number or a string. For instance, take the following function:</p><pre><code class="language-typescript"><span class="cm-comment">/**</span><span class="cm-comment"> * Takes a string and adds "padding" to the left.</span><span class="cm-comment"> * If 'padding' is a string, then 'padding' is appended to the left side.</span><span class="cm-comment"> * If 'padding' is a number, then that number of spaces is added to the left side.</span><span class="cm-comment"> */</span><span class="cm-keyword">function</span> <span class="cm-def">padLeft</span>(<span class="cm-def">value</span>: <span class="cm-type">string</span>, <span class="cm-def">padding</span>: <span class="cm-type">any</span>) {    <span class="cm-keyword">if</span> (<span class="cm-keyword">typeof</span> <span class="cm-variable-2">padding</span> <span class="cm-operator">===</span> <span class="cm-string">"number"</span>) {        <span class="cm-keyword">return</span> <span class="cm-variable">Array</span>(<span class="cm-variable-2">padding</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>).<span class="cm-property">join</span>(<span class="cm-string">" "</span>) <span class="cm-operator">+</span> <span class="cm-variable-2">value</span>;    }    <span class="cm-keyword">if</span> (<span class="cm-keyword">typeof</span> <span class="cm-variable-2">padding</span> <span class="cm-operator">===</span> <span class="cm-string">"string"</span>) {        <span class="cm-keyword">return</span> <span class="cm-variable-2">padding</span> <span class="cm-operator">+</span> <span class="cm-variable-2">value</span>;    }    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string-2">`Expected string or number, got '${</span><span class="cm-variable-2">padding</span><span class="cm-string-2">}</span><span class="cm-string-2">'.`</span>);}<span class="cm-variable">padLeft</span>(<span class="cm-string">"Hello world"</span>, <span class="cm-number">4</span>); <span class="cm-comment">// returns "    Hello world"</span></code></pre><p>The problem with <code>padLeft</code> is that its padding parameter is typed as <code>any</code>. That means that we can call it with an argument that’s neither a <code>number</code> nor a <code>string</code>, but TypeScript will be okay with it.</p><pre><code class="language-typescript"><span class="cm-keyword">let</span> <span class="cm-def">indentedString</span> <span class="cm-operator">=</span> <span class="cm-variable">padLeft</span>(<span class="cm-string">"Hello world"</span>, <span class="cm-atom">true</span>); <span class="cm-comment">// passes at compile time, fails at runtime.</span></code></pre><p>In traditional object-oriented code, we might abstract over the two types by creating a hierarchy of types. While this is much more explicit, it’s also a little bit overkill. One of the nice things about the original version of padLeft was that we were able to just pass in primitives. That meant that usage was simple and concise. This new approach also wouldn’t help if we were just trying to use a function that already exists elsewhere.</p><p>Instead of <code>any</code>, we can use a union type for the padding parameter:</p><pre><code class="language-typescript"><span class="cm-comment">/**</span><span class="cm-comment"> * Takes a string and adds "padding" to the left.</span><span class="cm-comment"> * If 'padding' is a string, then 'padding' is appended to the left side.</span><span class="cm-comment"> * If 'padding' is a number, then that number of spaces is added to the left side.</span><span class="cm-comment"> */</span><span class="cm-keyword">function</span> <span class="cm-def">padLeft</span>(<span class="cm-def">value</span>: <span class="cm-type">string</span>, <span class="cm-def">padding</span>: <span class="cm-type">string</span> <span class="cm-operator">|</span> <span class="cm-type">number</span>) {    <span class="cm-comment">// ...</span>}<span class="cm-keyword">let</span> <span class="cm-def">indentedString</span> <span class="cm-operator">=</span> <span class="cm-variable">padLeft</span>(<span class="cm-string">"Hello world"</span>, <span class="cm-atom">true</span>); <span class="cm-comment">// errors during compilation</span></code></pre><p>A union type describes a value that can be one of several types. We use the vertical bar (<code>|</code>) to separate each type, so <code>number | string | boolean</code> is the type of a value that can be a number, a string, or a boolean.</p><h2 id="task">Task</h2><p>Let’s have a look at some properties of TypeScript union types:</p><ul><li>Identity: <code>A|A</code> is equivalent to <code>A</code></li><li>Commutativity: <code>A|B</code> is equivalent to <code>B|A</code></li><li>Associativity: <code>(A|B)|C</code> is equivalent to <code>A|(B|C)</code></li><li>Subtype collapsing: <code>A|B</code> is equivalent to <code>A</code> if <code>B</code> is a subtype of <code>A</code></li></ul><p>I.e. if we have a value that has a union type, we can only access members that are common to all types in the union. If a value has the type <code>A | B</code>, we only know for certain that it has members that both <code>A</code> and <code>B</code> have.</p><p>Your task is to create function <code>join(tokens: string | string[], glue?: string): string</code> which can accept both <code>string</code> and <code>string[]</code> and return one string in which <code>tokens</code> are concatenated with the <code>glue</code>. </p><p><strong>Hint:</strong> Use <code>typeof</code> before calling <code>join</code> method.</p><p><strong>P.S.</strong> Solved this kata? Take a look at other katas in "<a href="https://www.codewars.com/collections/learning-typescript" data-turbolinks="false" target="_blank">Learning TypeScript</a>" collection.</p>